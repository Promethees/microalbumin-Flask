<!DOCTYPE html>
<html>
<head>
    <title>{{ title }}</title>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@2.0.0/dist/chartjs-plugin-annotation.min.js"></script>
    <style>
        body { 
            font-family: Arial, sans-serif; 
            margin: 20px; 
            display: flex;
            justify-content: center;
        }
        .container {
            max-width: 50vw;
            width: 100%;
        }
        .section { margin-bottom: 20px; }
        table { border-collapse: collapse; width: 100%; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f2f2f2; }
        #data-display { max-height: 300px; overflow-y: auto; }
        #error-message { color: red; display: none; }
        #file-table-container { max-height: 120px; overflow-y: auto; }
        #file-table { width: 100%; }
        #file-table tr.selected { background-color: #e0f7fa; }
        #file-table button { cursor: pointer; }
        #json-table { width: 100%; }
        #json-table tr.selected { background-color: #e0f7fa; }
        #json-table button { cursor: pointer; }
        #directory { width: 70%; }
        #dir-suggestions { margin-top: 5px; }
        #parent-dir, #child-dirs { margin-top: 5px; max-height: 100px; overflow-y: auto; }
        #parent-dir h3, #child-dirs h3 { margin: 0; font-size: 1em; font-weight: bold; }
        #parent-dir div, #child-dirs div { padding: 5px; cursor: pointer; }
        #parent-dir div:hover, #child-dirs div:hover { background-color: #f0f0f0; }
        #deselect-btn { margin-top: 5px; padding: 5px 10px; }
        #plot-canvas, #blanked-canvas, #non-blanked-canvas { width: 100%; height: 280px; }
        #chart-container { display: flex; flex-direction: column; gap: 20px; }
        #mode-toggle { margin-bottom: 10px; }
        #analysis-info { margin-top: 10px; font-size: 0.9em; color: #333; }
        #analysis-info.hidden { display: none; }
        #wd-size-error {color: red; display: none; }
        #log-display { max-height: 200px; overflow-y: auto; border: 1px solid #ddd; padding: 10px; background-color: #f9f9f9; white-space: pre-wrap; }
        .script-controls { margin-top: 10px; }
        #window-size-section { display: block; }
        #window-size-section.hidden { display: none; }
        #select-quantity-section { display: block; }
        #select-quantity-section.hidden { display: none; }
        #data-display-section { display: block; }
        #data-display-section.hidden { display: none; }
        #concentration-reader-section { display: block; }
        #concentration-reader-section.hidden { display: none; }
        #point-json-exp-section {display: block;}
        #point-json-exp-section.hidden { display: none; }
        #cal-json-sel-section { display: block; }
        #cal-json-sel-section.hidden { display: none; }
        #kinetics-lines { display: block; }
        #kinetics-lines.hidden { display: none; }
        #cal-json-exp-section {display: block;}
        #cal-json-exp-section.hidden { display: none; }
        #json-display { max-height: 200px; overflow-y: auto; border: 1px solid #ddd; padding: 10px; background-color: #f9f9f9; white-space: pre-wrap; }
        #json-display.hidden { display: none; }
        #derived-concentration-section { display: block; }
        #derived-concentration-section.hidden { display: none; }
        #blank-derived-concentration-section { display: block; }
        #blank-derived-concentration-section.hidden { display: none; }
        #non-blank-derived-concentration-section { display: block; }
        #non-blank-derived-concentration-section.hidden { display: none; }
        #export-analysis { display: block; }
        #export-analysis.hidden { display: none; }
        #set-exp-point-section { display: block; }
        #set-exp-point-section.hidden { display: none; }
        #select-exp-blank-type { display: block; }
        #select-exp-blank-type.hidden { display: none; }
        #range-display { display: block; }
        #range-display.hidden { display: none; }
        #full-display-section { display: block; }
        #full-display-section.hidden { display: none; }
    </style>
</head>
<body>
    <div class="container">
        <h1>{{ title }}</h1>
        
        <div class="section">
            <h2>Directory</h2>
            <input type="text" id="directory" value="{{ directory }}" onchange="updateDirectory(this.value)">
            <button onclick="browseDirectory()">Browse Path</button>
            <div id="dir-suggestions">
                <h3>Go back</h3>
                <div id="parent-dir"></div>
                <h3>Go forward</h3>
                <div id="child-dirs"></div>
            </div>
            <div id="error-message"></div>
        </div>
        <div class="section script-controls">
            <h2>Log HID Data</h2>
            <div>
                <label for="base-dir">Base Directory (--base-dir): </label>
                <input type="text" id="base-dir" placeholder="Enter directory to save recorded data from the Colorimeter. Leave empty to save to default directory" style="width: 50em">
            </div>
            <div>
                <label for="base-name">Base Name (--base-name): </label>
                <input type="text" id="base-name" placeholder="Enter a name for pattern for recorded data files' names" style="width: 10em">
            </div>
            <button id="run-script-btn" onclick="runScript()">Run Script</button>
            <button id="terminate-script-btn" onclick="terminateScript()" disabled>Terminate Script</button>
            <button id="clear-logs-btn" onclick="clearLogs()">Clear Logs</button>
            <div id="log-display"></div>
        </div>
        <div class="section">
            <h2>{{ mode_input.title }}</h2>
            <select id="measurement-mode">
                {% for mode in mode_input.modes %}
                <option value="{{ mode }}">{{ mode }}</option>
                {% endfor %}
            </select>
        </div>
        <div class="section" id="cal-json-exp-section"> 
            <h3>Select type of Calibration you'd like to do</h3>
            <select id="cal-mode-select">
                <option value="kinetics">kinetics</option>
                <option value="point">point</option>
            </select>
        </div>  
        <div class="section" id="cal-json-sel-section">
            <div id="file-table-container">
                <table id="json-table">
                    <tr><th>Calibrated JSON</th><th>Action</th></tr>
                    {% if cal_json_list %}
                        {% for file in cal_json_list %}
                        <tr>
                            <td>{{ file }}</td>
                            <td><button onclick="selectFile('{{ file }}', this, '#json-table')">Select</button></td>
                        </tr>
                        {% endfor %}
                    {% else %}
                        <tr><td colspan="2">No Calibrated JSON is available.</td></tr>
                    {% endif %}
                </table> 
            </div>
            <button id="deselect-btn" onclick="deselectFile('#json-table')">Deselect</button>
            <div id="json-display"></div>
        </div>
        <div class="section">
            <h2>File Selection</h2>
            <div id="file-table-container">
                <table id="file-table">
                    <tr><th>File Name</th><th>Action</th></tr>
                    {% if file_list %}
                        {% for file in file_list %}
                        <tr>
                            <td>{{ file }}</td>
                            <td><button onclick="selectFile('{{ file }}', this)">Select</button></td>
                        </tr>
                        {% endfor %}
                    {% else %}
                        <tr><td colspan="2">No CSV files found in the directory.</td></tr>
                    {% endif %}
                </table>
            </div>
            <button id="deselect-btn" onclick="deselectFile()">Deselect</button>
        </div>
        <div class="section" id="data-display-section">
            <h2>Data Display</h2>
            <!-- Display selected file name -->
            <div id="selected-file-display">No file selected</div>
            <div id="concentration-reader-section">
                Concentration from the csv is <input type="number" id="con-value-read" value="" min=0 style="width: 5em;"> </input> nM/l
            </div>
            <div class="section" id="point-json-exp-section">
                Reference point is at <span type="number" id="cal-point"></span> <span id="cal-time-unit" style="font-weight: bold;">second</span><span id="add-json-section"></span>
            </div>
            <div class="section" id="window-size-section">
                Select window size for Vmax regression
                <input type="number" id="window-size" value="4" min="3" style="width: 5em;">
                <div id="wd-size-error"></div>
            </div>
            <div class="section" id="select-quantity-section">
                Select quantity to derive concentration from
                <select id="regressed-quantity">
                    {% for quantity in quantity_input.quantities %}
                        {% set transformed = quantity.lower().replace(' ', '_') %}
                        <option value="{{ transformed }}" data-original="{{ quantity }}">{{ quantity }}</option>
                    {% endfor %}
                </select>

            </div>
            <div id="derived-concentration-section">
                Concentration derived from the csv is <span style="font-weight: bold;" id="der-con-value"></span> nM/l
            </div>
            <div id="blank-derived-concentration-section">
                <span style="font-weight: bold;"> Blanked </span>concentration derived from the csv is <span style="font-weight: bold;" id="blank-der-con-value"></span> nM/l
            </div>
            <div id="non-blank-derived-concentration-section">
                <span style="font-weight: bold;"> Non blanked</span> concentration derived from the csv is <span style="font-weight: bold;" id="non-blank-der-con-value"></span> nM/l
            </div>
            <div class="section" id="range-display">
                <h3>{{ range_input.title }}</h3>
                <input type="number" id="range-value" value="{{ range_input.value }}" min="1">
                <select id="time-unit">
                    {% for unit in range_input.units %}
                    <option value="{{ unit }}">{{ unit }}</option>
                    {% endfor %}
                </select>
            </div>
            <div id="mode-toggle">
                <label>
                    <input type="checkbox" id="split-mode" onchange="toggleMode()"> Split by Blanked
                </label>
                <label id="full-display-section">
                    <input type="checkbox" id="full-display" onchange="toggleMode()"> Full display: See all data and special lines</p>
                </label>
                <label>
                </label>
            </div>
            <div id="export-analysis">
                <div>
                    <h3>Export analysis</h3>
                    <div class="section" id="set-exp-point-section">
                        Set reference point to export: <input type="number" id="exp-json-time-value" style="width: 5em;"> <span style="font-weight: bold;"> minute </span><span id="est-val-exp"></span>
                    </div>
                    <div id="select-exp-blank-type">
                        Select Blank type to export/regress:
                        <select id="exp-json-blank-type">
                            <option value="MIXED">MIXED</option>
                            <option value="BLANKED">BLANKED</option>
                            <option value="NON-BLANKED">NON-BLANKED</option>
                        </select>
                    </div>
                    <label for="save-dir">Saving Directory: 
                    </label>
                    <input type="text" id="save-dir" placeholder="Enter directory path to save analysis data. Leave empty to save to default directory" style="width: 50em">
                </div>
                <div>
                    <label for="save-file">File Name: </label>
                    <input type="text" id="save-file" placeholder="Enter file name to save analysis data to(e.g., results)" style="width: 10em">
                </div>
                <button id="export-btn" onclick="exportData()">Export Data</button>
                <p id="export-data-warning" style="color: red;"><span style="font-weight: bold;">Warning!</span> Exporting data is only supported when Time unit in <span style="font-weight: bold;">Display Range</span> is set to <span style="font-weight: bold;">"minutes"!</span></p>
            </div>  
            <div id="analysis-info"></div>
            <div id="chart-container">
                <canvas id="plot-canvas"></canvas>
                <canvas id="blanked-canvas" style="display: none;"></canvas>
                <canvas id="non-blanked-canvas" style="display: none;"></canvas>
            </div>   
        </div>
    </div>

    <script>
        let blankedChart = null;
        let nonBlankedChart = null;
        let myChart = null;
        let scriptRunning = false;
        let currentMeasurementMode = "kinetics";
        let currentFile = null;
        let currentJSON = null;
        let currentJSONcontent = null;

        const platform = navigator.platform.toLowerCase();
        const delimiter = platform.includes("window") ? "\\" : "/";
        let refCalPoint = null;
        let analysis = null;
        let json_msg = 'When fit_type: \n';
        let globalEstimatedValue = null;
        let currExpTimePoint = null

        json_msg += '  + linear: concentration = quantity_json[0]*quantity_value + quantity_json[1]\n';
        json_msg += '  + polynomial: concentration = quantity_json[0]*quantity_value^2 + quantity_json[1]*quantity_value + quantity_json[2]\n';
        json_msg += '  + logarit: concentration = quantity_json[0]*loge(quantity_json[1]*quantity_value)\n';

        $("#point-json-exp-section").addClass("hidden");
        $("#cal-json-exp-section").addClass("hidden");
        $("#derived-concentration-section").addClass("hidden");
        $("#blank-derived-concentration-section").addClass("hidden");
        $("#non-blank-derived-concentration-section").addClass("hidden");
        $("#set-exp-point-section").addClass("hidden");

        const input = document.getElementById("window-size");

        input.addEventListener("keydown", function (e) {
            // Allow: ArrowUp, ArrowDown, Tab, etc.
            if (
              ["ArrowUp", "ArrowDown", "Tab"].includes(e.key)
            ) return;

            // Prevent all other key presses
            e.preventDefault();
          });

        $(document).ready(function() {
            $.get('/get_parents', function(parentResponse) {
                console.log("Parent directory:", parentResponse.parent);
                let parentHtml = parentResponse.parent ? 
                    `${parentResponse.parent.split(delimiter).pop() ? 
                        `<div onclick="updateDirectory('${parentResponse.parent}', 'true')">${parentResponse.parent.split(delimiter).pop()}</div>` : 
                        '<div>No parent directory</div>'}` : 
                    '<div>No parent directory</div>';
                $("#parent-dir").html(parentHtml);

                $.get('/get_children', function(childResponse) {
                    console.log("Child directories:", childResponse.children);
                    let childHtml = childResponse.children.length > 0 ? 
                        `${childResponse.children.map(dir => 
                            `<div onclick="updateDirectory('${dir}', 'true')">${dir.split(delimiter).pop()}</div>`
                        ).join('')}` : 
                        '<div>No child directories</div>';
                    $("#child-dirs").html(childHtml);
                }).fail(function(jqXHR, textStatus, errorThrown) {
                    console.log("Error fetching child directories:", textStatus, errorThrown);
                    $("#error-message").text("Error fetching child directories").show();
                });
            }).fail(function(jqXHR, textStatus, errorThrown) {
                console.log("Error fetching parent directory:", textStatus, errorThrown);
                $("#error-message").text("Error fetching parent directory").show();
            });

            // Poll logs every 2 seconds if script is running
            setInterval(function() {
                if (scriptRunning) {
                    fetchLogs();
                }
            }, 2000);

            // Periodically update file table every 0.5 seconds
            setInterval(function() {
                const currentDir = $("#directory").val();
                if (currentDir) {
                    updateDirectory(currentDir, false);
                }
            }, 2000);

            $("#time-unit").on("change", function(){
                const currTimeUnit = $(this).val().slice(0, -1);
                $("#cal-time-unit").text(currTimeUnit);
            })
            // Initialize measurement method listener
            $("#measurement-mode").on("change", function() {
                const mode = $(this).val();
                currentMeasurementMode = mode;
                console.log("curr mode", currentMeasurementMode);
                const currentDir = $("#directory").val();
                if (currentDir) {
                    updateDirectory(currentDir, true);
                }
                currentJSON = null;
                currentJSONcontent = null;
                $("#json-display").text("");
                if (mode === "kinetics") {
                    $("#window-size-section").removeClass("hidden");
                    $("#select-quantity-section").removeClass("hidden");
                    $("#point-json-exp-section").addClass("hidden");
                    $("#cal-json-sel-section").removeClass("hidden");
                    $("#kinetics-lines").removeClass("hidden");
                    $("#cal-json-exp-section").addClass("hidden");
                    $("#range-value").val("1000").prop("disabled", false);
                    $("#json-display").removeClass("hidden");
                    $("#export-analysis").removeClass("hidden");
                    $("#set-exp-point-section").addClass("hidden");
                    $("#select-exp-blank-type").removeClass("hidden");
                    $("#range-display").removeClass("hidden");
                    $("#concentration-reader-section").removeClass("hidden");
                    $("#analysis-info").removeClass("hidden");
                    $("#full-display-section").removeClass("hidden");
                } else if (mode === "point"){
                    $("#window-size-section").addClass("hidden");
                    $("#select-quantity-section").addClass("hidden"); 
                    $("#point-json-exp-section").addClass("hidden");
                    $("#cal-json-sel-section").removeClass("hidden");
                    $("#kinetics-lines").addClass("hidden");
                    $("#cal-json-exp-section").addClass("hidden");
                    $("#range-value").val("1000").prop("disabled", false);
                    $("#json-display").removeClass("hidden");
                    $("#export-analysis").removeClass("hidden");
                    $("#set-exp-point-section").removeClass("hidden");
                    $("#select-exp-blank-type").removeClass("hidden");
                    $("#range-display").removeClass("hidden");
                    $("#concentration-reader-section").removeClass("hidden");
                    $("#analysis-info").removeClass("hidden");
                    $("#full-display-section").removeClass("hidden");
                } else {
                    $("#window-size-section").addClass("hidden");
                    if ($("#cal-mode-select").val() === "kinetics") 
                        $("#select-quantity-section").removeClass("hidden");
                    else $("#select-quantity-section").addClass("hidden"); 
                    $("#point-json-exp-section").addClass("hidden");
                    $("#cal-json-sel-section").addClass("hidden");
                    $("#kinetics-lines").addClass("hidden");
                    $("#cal-json-exp-section").removeClass("hidden");
                    $("#range-value").val("").prop("disabled", true).attr("placeholder", "Disabled in Calibration mode");
                    $("#json-display").addClass("hidden");
                    $("#export-analysis").addClass("hidden");
                    $("#select-exp-blank-type").addClass("hidden");
                    $("#range-display").addClass("hidden");
                    $("#concentration-reader-section").addClass("hidden");
                    $("#full-display-section").addClass("hidden");
                }
                if (currentFile) {
                    if (currentMeasurementMode !== "calibrate") {
                        let range = $("#range-value").val();
                        let unit = $("#time-unit").val();
                        let window_size = $("#window_size").val();
                        fetchData(range, unit, window_size, currentFile);
                    } else {
                        fetchData(null, null, null, currentFile, null);
                    }
                } 
                updateDirectory($("#directory").val(), true); // Refresh file table based on new mode
            });

            $("#cal-json-exp-section").on("change", function() {
                currentFile = null;
            });

            if (currentFile) {
                $("#data-display-section").removeClass("hidden");
            } else $('#data-display-section').addClass("hidden");
        });

        function browseDirectory() {
            $.get('/get_parents', function(parentResponse) {
                console.log("Parent directory:", parentResponse.parent);
                let parentHtml = parentResponse.parent ? 
                    `${parentResponse.parent.split(delimiter).pop() ? 
                        `<div onclick="updateDirectory('${parentResponse.parent}', 'true')">${parentResponse.parent.split(delimiter).pop()}</div>` : 
                        '<div>No parent directory</div>'}` : 
                    '<div>No parent directory</div>';
                $("#parent-dir").html(parentHtml);

                $.get('/get_children', function(childResponse) {
                    console.log("Child directories:", childResponse.children);
                    let childHtml = childResponse.children.length > 0 ? 
                        `${childResponse.children.map(dir => 
                            `<div onclick="updateDirectory('${dir}', 'true')">${dir.split(delimiter).pop()}</div>`
                        ).join('')}` : 
                        '<div>No child directories</div>';
                    $("#child-dirs").html(childHtml);
                }).fail(function(jqXHR, textStatus, errorThrown) {
                    console.log("Error fetching child directories:", textStatus, errorThrown);
                    $("#error-message").text("Error fetching child directories").show();
                });
            }).fail(function(jqXHR, textStatus, errorThrown) {
                console.log("Error fetching parent directory:", textStatus, errorThrown);
                $("#error-message").text("Error fetching parent directory").show();
            });
        }

        function updateDirectory(path, deselect) {
            console.log("Sending path to server:", path);
            $.post('/browse', {path: path}, function(response) {
                console.log("Server response:", response);
                if (response.status === 'success') {
                    $("#directory").val(response.path);
                    $("#error-message").hide();
                    // console.log("Response files in update directory is: ". response.files);
                    updateFileTable(response.files, deselect);
                    if (deselect) {
                        deselectFile();
                    }
                } else {
                    $("#error-message").text(response.message).show();
                }
            }).fail(function(jqXHR, textStatus, errorThrown) {
                console.log("AJAX error:", textStatus, errorThrown);
                $("#error-message").text("Error updating directory").show();
            });
            $.get('/get_json_cal', {mode: currentMeasurementMode}, function(response) {
                updateJSONTable(response.files);
            })
        }

        async function filterFiles(files) {
            const checks = await Promise.all(
                files.map(async (fileName) => {
                    const filePath = $("#directory").val() + delimiter + fileName;

                    try {
                        const response = await fetch('/get_headers?file=' + encodeURIComponent(filePath));
                        const data = await response.json();
                        const meas_headers = ["Timestamp","Measurement","Value","Unit","Type","Blanked","Concentration"];
                        const cal_headers_kinetics = ["Measurement","Concentration","Vmax","Slope","Sat","Time To Sat", "MeasUnit", "TimeUnit","BlankType", "MeasMode"];
                        const cal_headers_point = ["Measurement","Concentration", "Value", "MeasUnit", "TimePoint", "TimeUnit", "BlankType", "MeasMode"];
                        if (data.headers) {
                            const isMeasHeader = JSON.stringify(data.headers) === JSON.stringify(meas_headers);
                            // const isCalHeader = JSON.stringify(data.headers) === JSON.stringify(cal_headers_1) || JSON.stringify(data.headers) === JSON.stringify(cal_headers_2);
                            if (currentMeasurementMode === "kinetics" || currentMeasurementMode === "point") {
                                // console.log("current data header is", data.headers);
                                return isMeasHeader;
                            } else if (currentMeasurementMode === "calibrate") {
                                const cal_type = $("#cal-mode-select").val();
                                // console.log("the cal type is ", cal_type);
                                let isCalHeader = false;
                                if (cal_type === "kinetics") {
                                    isCalHeader = JSON.stringify(data.headers) === JSON.stringify(cal_headers_kinetics);
                                }
                                else {
                                    isCalHeader = JSON.stringify(data.headers) === JSON.stringify(cal_headers_point);
                                }
                                return isCalHeader;
                            }
                            // return currentMeasurementMode === "kinetics" ? hasTimestamp : !hasTimestamp;
                        }
                        return false; // on error or no headers
                    } catch (error) {
                        console.error("Failed to fetch headers for", fileName, error);
                        return false;
                    }
                })
            );

            // Now filter files based on the results
            const filteredFiles = files.filter((_, idx) => checks[idx]);

            return filteredFiles;
        }

        function updateJSONTable(files) {
            let html = '<tr><th>Calibrated JSON</th><th>Action</th></tr>';
            if (files && files.length > 0) {
                files.forEach(file => {
                   const isSelected = file === currentJSON ? ' class="selected"' : ''; 
                   html += `<tr${isSelected}><td>${file}</td><td><button onclick="selectFile('${file}', this, '#json-table')">Select</button></td></tr>`;
                })
            } else {
                html += '<tr><td colspan="2">No Calibrated JSON is available.</td></tr>'; 
            }
            $("#json-table").html(html);
        }

        function updateFileTable(files, deselect) {

            let html = '<tr><th>File Name</th><th>Action</th></tr>';

            filterFiles(files).then((filteredFiles) => {
                if (filteredFiles && filteredFiles.length > 0) {
                    filteredFiles.forEach(file => {
                        const isSelected = file === currentFile ? ' class="selected"' : '';
                        html += `<tr${isSelected}><td>${file}</td><td><button onclick="selectFile('${file}', this)">Select</button></td></tr>`;
                    });
                } else {
                    html += '<tr><td colspan="2">No CSV files found in the directory.</td></tr>';
                }
                $("#file-table").html(html);
                if (deselect) {
                    currentFile = null;
                    $("#file-table tr").removeClass("selected");
                    updateFileDisplay(currentFile);
                }
            });  
        }

        function updateFileDisplay(curFile) {
            const displayElement = document.getElementById('selected-file-display');
            if (curFile)
                $("#selected-file-display").html(`Selected File: ${curFile}`);
            else
                $("#selected-file-display").html(`No file selected`);
        }

        function fetchJSON(jsonFile, callback) {
            $.get('/get_json_content', {
                json_name: jsonFile,
                mode: currentMeasurementMode
            }, function(response) {
                console.log("Retrieved json data is", response.json);
                callback(response.json, response.path);
            })
        }

        function selectFile(fileName, button, tableSelector = "#file-table") {
            console.log("Selected file:", fileName);
            console.log("Table selector is ", tableSelector);
            
            // Clear previous selection and highlight the current row
            $(`${tableSelector} tr`).removeClass("selected");
            $(button).closest("tr").addClass("selected");

            if (tableSelector === "#file-table") {
                currentFile = fileName;
                processDataDisplay(currentFile);
            } else if (tableSelector === "#json-table") {
                currentJSON = fileName;
                fetchJSON(currentJSON, function(JSON_content, JSON_path) {
                    console.log("Fetched JSON is ", JSON_content);
                    // console.log("Select json file", currentJSON);
                    $("#json-display").text(`Current mode is \"${currentMeasurementMode}\".\nJSON file read from ${JSON_path}\n`);
                    if (currentMeasurementMode === "kinetics") {
                        $("#json-display").append("Quantity value is either Vmax, Slope, Saturation, Time to Saturation, which ever is set by user.\n");
                    } else if (currentMeasurementMode === "point") {
                         $("#json-display").append("Quantity value is the Absorbance value read from selected data file whose recorded time is the closest to the time set in this JSON.\n");
                    }
                    $("#json-display").append(`${json_msg}`);
                    $("#json-display").append(JSON.stringify(JSON_content, null, 4));
                    currentJSONcontent = JSON_content;
                    if (currentFile) 
                        processDataDisplay(currentFile, currentJSONcontent);
                });
            }    
        }

        function processDataDisplay(fileName, jsonFileContent=null) {
            // Get user inputs
            let range = $("#range-value").val();
            let unit = $("#time-unit").val();
            let window_size = $("#window-size").val();

            // Validate window size
            if (window_size < 3) {
                $("#wd-size-error").text("Window size must be greater than 3.").show();
                return;
            }

            if (!Number.isInteger(parseInt(window_size, 10)) || window_size === '' || isNaN(window_size)) {
                $("#wd-size-error").text("Window size must be an integer.").show();
                return;
            }

            // Clear error message if input is valid
            $("#wd-size-error").hide();

            // Proceed with fetching and displaying data
            fetchData(range, unit, window_size, fileName, jsonFileContent);
            updateFileDisplay(fileName);
        }


        function deselectFile(tableSelector="#file-table") {
            // console.log("Deselecting file");
            $(`${tableSelector} tr`).removeClass("selected");
            if (tableSelector === "#file-table") {
                destroyCharts();
                $("#plot-canvas, #blanked-canvas, #non-blanked-canvas").hide();
                currentFile = null;
                $("#analysis-info").text("");
                updateFileDisplay(currentFile);
            } else if (tableSelector === "#json-table") {
                currentJSON = null;
                currentJSONcontent = null;
                $("#json-display").text("");
                processDataDisplay(currentFile, currentJSONcontent);
                $("#derived-concentration-section").addClass("hidden");
                $("#blank-derived-concentration-section").addClass("hidden");
                $("#non-blank-derived-concentration-section").addClass("hidden");
                $("#point-json-exp-section").addClass("hidden");
            }
        }

        function settingDerivedCon(jsonFile) {
            let derived_section = null;
            let derived_con_text = null;
            switch(jsonFile["for_blank_type"]) {
                case "MIXED":
                    if (!$("#split-mode").is(":checked")) {
                        derived_section = document.getElementById('derived-concentration-section');
                        derived_con_text = document.getElementById('der-con-value');
                    }
                    break;
                case "BLANKED":
                    if ($("#split-mode").is(":checked")) {
                        derived_section = document.getElementById('blank-derived-concentration-section');
                        derived_con_text = document.getElementById('blank-der-con-value');
                    }
                    break;
                case "NON-BLANKED":
                    if ($("#split-mode").is(":checked")) {
                        derived_section = document.getElementById('non-blank-derived-concentration-section');
                        derived_con_text = document.getElementById('non-blank-der-con-value');
                    }
                    break;
            }
            return {
                derived_section: derived_section,
                derived_con_text: derived_con_text
            }
        }

        function getEstimatedValue(data, timepoint, blankType = "MIXED", maxTolerance = 60) {
        if (!Array.isArray(data) || data.length === 0) return null;

            // Sort data by timestamp
            data.sort((a, b) => a["Timestamp"] - b["Timestamp"]);

            // Filter data based on blankType
            const filteredData = data.filter(item => {
                if (blankType === "MIXED") return true;
                if (blankType === "BLANKED") return item["Blanked"] === true; // Changed from "Blank" to "Blanked"
                if (blankType === "NON-BLANKED") return item["Blanked"] === false; // Changed from "Blank" to "Blanked"
                return true; // Default to MIXED behavior
            });
            // console.log("Current blank type is ", blankType);
            // console.log("Filtered data are ", filteredData);

            if (filteredData.length === 0) return null;

            // Loop to find the two surrounding points
            for (let i = 0; i < filteredData.length - 1; i++) {
                const t1 = filteredData[i]["Timestamp"];
                const t2 = filteredData[i + 1]["Timestamp"];

                // Exact match
                if (t1 === timepoint) return filteredData[i]["Value"];
                if (t2 === timepoint) return filteredData[i + 1]["Value"];

                // Surrounding range for interpolation
                if (t1 < timepoint && timepoint < t2) {
                    const minDiff = Math.min(Math.abs(timepoint - t1), Math.abs(timepoint - t2));
                    if (minDiff > maxTolerance) return null;

                    const v1 = filteredData[i]["Value"];
                    const v2 = filteredData[i + 1]["Value"];

                    const ratio = (timepoint - t1) / (t2 - t1);
                    return v1 + ratio * (v2 - v1);
                }
            }

            // Check ends if out-of-bounds but within tolerance
            const first = filteredData[0], last = filteredData[filteredData.length - 1];
            if (Math.abs(timepoint - first["Timestamp"]) <= maxTolerance) return first["Value"];
            if (Math.abs(timepoint - last["Timestamp"]) <= maxTolerance) return last["Value"];

            return null;
    }


        function fetchData(range, unit, window_size, filename, jsonFile) {
            // console.log("JSON file is ", jsonFile);
            const fullPath = $("#directory").val() + delimiter + filename;
            console.log(`Sending request to ${fullPath}`);
            $.get('/get_data', {
                file: $("#directory").val() + delimiter + filename
            }, function(response) {
                console.log("Response is ", response);
                if (response.data && response.data.length > 0) {
                    if (window_size > response.data.length / 2) {
                        $("#plot-canvas, #blanked-canvas, #non-blanked-canvas").hide();
                        $("#analysis-info").html(`<span style="color: red;">Window Size is greater than half of data size. The file has only ${response.data.length} data points</span>`);
                    } else {
                        // console.log(`Current mode is ${currentMeasurementMode} and we're fetching Data of ${$("#cal-mode-select").val()}`);
                        let derivedConSettings = null;
                        let derived_section = null;
                        let derived_con_text = null;
                        if (jsonFile) {
                            derivedConSettings = settingDerivedCon(jsonFile);
                            console.log("Derived con settings is ", derivedConSettings);
                            derived_section = derivedConSettings.derived_section;
                            derived_con_text = derivedConSettings.derived_con_text;
                            if (derived_section) {
                                derived_section.classList.remove("hidden");
                            } else { // derived_section is null -> hide all
                                $("#derived-concentration-section").addClass("hidden");
                                $("#blank-derived-concentration-section").addClass("hidden");
                                $("#non-blank-derived-concentration-section").addClass("hidden");
                            }
                        }

                        const isSplitMode = $("#split-mode").is(":checked");
                        const isFullDisplay = $("#full-display").is(":checked");
                        const displayRangeInput = document.getElementById('range-value');
                        const fullDisplayCheckbox = document.getElementById('full-display');

                        // Move event listener outside the AJAX callback or nest it properly
                        fullDisplayCheckbox.addEventListener('change', function() {
                            const originalValue = displayRangeInput.value; // Fixed 'input' to 'value'
                            if (this.checked) {
                                displayRangeInput.disabled = true;
                                displayRangeInput.placeholder = "Disabled by Full Display";
                                displayRangeInput.value = "";
                            } else {
                                displayRangeInput.disabled = false;
                                displayRangeInput.value = originalValue || 1000; // Restore original or default to 1000
                            }
                        });

                        if (currentMeasurementMode === "point" && jsonFile) {
                            analysis = updatePlot(response.data, range, unit, window_size, response.unit || "NONE", isSplitMode, isFullDisplay, refCalPoint, jsonFile["for_blank_type"]);
                        } else {
                            if (currentMeasurementMode === "calibrate") {
                                const cal_type = $("#cal-mode-select").val();
                                const quantity_obj = document.getElementById('regressed-quantity');
                                if (cal_type === "kinetics") {
                                    updatePlot(response.data, range=null, unit=null, window_size=null, response.data[0]["MeasUnit"], isSplitMode, true, null, null, "Concentration", quantity_obj.selectedOptions[0].text);
                                } else if (cal_type === "point") {
                                    updatePlot(response.data, range=null, unit=null, window_size=null, response.data[0]["MeasUnit"], isSplitMode, true, null, null, "Concentration", "Value");
                                }
                            } else {
                                analysis = updatePlot(response.data, range, unit, window_size, response.unit || "NONE", isSplitMode, isFullDisplay);
                            }
                        }

                        if (currentMeasurementMode !== "calibrate") {                            
                            const conValueInput = document.getElementById('con-value-read');
                            const conValueFromFile = response.data.map(row => row['Concentration'])[0];

                            if (conValueFromFile !== "NONE") {
                                conValueInput.value = conValueFromFile;
                                conValueInput.disabled = true;
                            } else {
                                conValueInput.disabled = false;
                                conValueInput.value = "";
                            }

                            if (currentMeasurementMode === "kinetics") {
                                const conQuantityInput = document.getElementById('regressed-quantity').value;
                                if (jsonFile) {
                                    const coef = jsonFile[conQuantityInput]["fit_coef"];
                                    let value = null;
                                    switch(conQuantityInput) {
                                        case "vmax":
                                            if (jsonFile["for_blank_type"] === "MIXED") {
                                                value = analysis.vmax * 60;
                                            } else if (jsonFile["for_blank_type"] === "BLANKED") {
                                                value = analysis.vmax_blanked * 60;
                                            } else if (jsonFile["for_blank_type"] === "NON-BLANKED") {
                                                value = analysis.vmax_non_blanked * 60;
                                            }
                                            break;
                                        case "slope":
                                            if (jsonFile["for_blank_type"] === "MIXED") {
                                                value = analysis.slope * 60;
                                            } else if (jsonFile["for_blank_type"] === "BLANKED") {
                                                value = analysis.slope_blanked * 60;
                                            } else if (jsonFile["for_blank_type"] === "NON-BLANKED") {
                                                value = analysis.slope_non_blanked * 60;
                                            }
                                            break;
                                        case "sat":
                                            if (jsonFile["for_blank_type"] === "MIXED") {
                                                value = analysis.sat;
                                            } else if (jsonFile["for_blank_type"] === "BLANKED") {
                                                value = analysis.sat_blanked;
                                            } else if (jsonFile["for_blank_type"] === "NON-BLANKED") {
                                                value = analysis.sat_non_blanked;
                                            }
                                            break;
                                        case "time_to_sat":
                                            if (jsonFile["for_blank_type"] === "MIXED") {
                                                value = analysis.time_to_sat / 60;
                                            } else if (jsonFile["for_blank_type"] === "BLANKED") {
                                                value = analysis.time_to_sat_blanked / 60;
                                            } else if (jsonFile["for_blank_type"] === "NON-BLANKED") {
                                                value = analysis.time_to_sat_non_blanked / 60;
                                            }
                                            break;
                                    }
                                    calculated_con = computeFit(value, jsonFile["fit_type"], coef);
                                    derived_con_text.innerHTML = `${calculated_con}`;
                                }
                            } else if (currentMeasurementMode === "point") {
                                if (jsonFile) {
                                    const timeUnitSet = $("#time-unit").val();
                                    const calPoint = $("#cal-point");
                                    $("#point-json-exp-section").removeClass("hidden");

                                    const jsonTimePoint = jsonFile["time"];
                                    const jsonTimeUnit = jsonFile["time-unit"];

                                    const baseMultiplier = getTimeUnitMultiplier(jsonTimeUnit);
                                    const targetMultiplier = getTimeUnitMultiplier(timeUnitSet);
                                    const conversionFactor = baseMultiplier / targetMultiplier;
                                    refCalPoint = jsonTimePoint * conversionFactor;
                                    calPoint.text(refCalPoint);

                                    const estValueRead = getEstimatedValue(response.data, jsonTimePoint * 60, jsonFile["for_blank_type"]).toFixed(4);
                                    if (estValueRead) {
                                        const unitPrinted = response.data[0]["Unit"] === "NONE" ? "" : response.data[0]["Unit"];
                                        $("#add-json-section").text(`. The estimated value read from recorded data is ${estValueRead}${unitPrinted}.`);
                                    } else {
                                        $("#add-json-section").text("");
                                    }
                                    calculated_con = computeFit(estValueRead, jsonFile["fit_type"], jsonFile["fit_coef"]);
                                    derived_con_text.innerHTML = `${calculated_con}`;
                                }
                                const currExpTimePoint = $("#exp-json-time-value").val();
                                let currExpBlankType = $("#exp-json-blank-type").val();
                                if (currExpTimePoint) {
                                    globalEstimatedValue = getEstimatedValue(response.data, currExpTimePoint * 60, currExpBlankType);
                                }
                            }
                        } else {
                            $("#derived-concentration-section").addClass("hidden");
                            $("#blank-derived-concentration-section").addClass("hidden");
                            $("#non-blank-derived-concentration-section").addClass("hidden");
                        }
                    }
                } else {
                    $("#plot-canvas, #blanked-canvas, #non-blanked-canvas").hide();
                    $("#analysis-info").html(`<span style="color: red;">No data available</span>`);
                }
            }).fail(function(xhr, status, error) {
                console.error("Failed to fetch data:", status, error, xhr.responseText);
            }); // Close $.get callback
        } // Close fetchData function

        function destroyCharts() {
            if (myChart) {
                myChart.destroy();
                myChart = null;
            }
            if (blankedChart) {
                blankedChart.destroy();
                blankedChart = null;
            }
            if (nonBlankedChart) {
                nonBlankedChart.destroy();
                nonBlankedChart = null;
            }
        }

        function toggleMode() {
            if (currentFile) {
                if (currentMeasurementMode !== "calibrate") {
                    let range = $("#range-value").val();
                    let unit = $("#time-unit").val();
                    let window_size = $("window_size").val();
                    fetchData(range, unit, window_size, currentFile);
                } else fetchData(null, null, null, currentFile);
            }
        }

        function computeFit(value, fit_type, coef) {
            switch (fit_type.toLowerCase()) {
                case "linear":
                    // Expect coef = [a, b]
                    if (coef.length < 2) throw new Error("Linear fit requires 2 coefficients: [a, b]");
                    return coef[0] * value + coef[1];

                case "polynomial":
                    // Expect coef = [a, b, c]
                    if (coef.length < 3) throw new Error("Polynomial fit requires 3 coefficients: [a, b, c]");
                    return coef[0] * Math.pow(value, 2) + coef[1] * value + coef[2];

                case "logarit":
                case "logarithmic":
                    // Expect coef = [a, b]
                    if (coef.length < 2) throw new Error("Logarithmic fit requires 2 coefficients: [a, b]");
                    if (coef[1] * value <= 0) throw new Error("Invalid input for logarithm: b * value must be > 0");
                    return coef[0] * Math.log(coef[1] * value);

                default:
                    throw new Error("Unknown fit type: " + fit_type);
            }
        }


        function calculateSlopeAndSaturation(allTimestamps, allValues, window_size) {
            if (allTimestamps.length < 2 || allValues.length < 2 || window_size < 2 || window_size > allTimestamps.length) {
                return { slope: 0, intercept: 0, saturationValue: "--", timeToSaturation: "--", Vmax: 0, linearSlope: 0, linearYMin: 0, linearYMax: 0, linearXMin: 0, linearXMax: 0 };
            }

            // Function to calculate R-squared for linear regression
            function calculateRSquared(x, y, slope, intercept) {
                let n = x.length;
                let sumY = y.reduce((a, b) => a + b, 0);
                let meanY = sumY / n;
                let ssTot = y.reduce((a, b) => a + Math.pow(b - meanY, 2), 0);
                let ssRes = x.reduce((a, b, i) => a + Math.pow(y[i] - (slope * b + intercept), 2), 0);
                return ssTot === 0 ? 1 : 1 - ssRes / ssTot;
            }

            // Calculate local slopes and R-squared for each window
            let localSlopes = [];
            let intercepts = [];
            let rSquaredValues = [];
            for (let i = 0; i <= allTimestamps.length - window_size; i++) {
                let x = allTimestamps.slice(i, i + window_size);
                let y = allValues.slice(i, i + window_size);

                let n = x.length;
                let sumX = x.reduce((a, b) => a + b, 0);
                let sumY = y.reduce((a, b) => a + b, 0);
                let sumXY = x.reduce((a, b, i) => a + b * y[i], 0);
                let sumXX = x.reduce((a, b) => a + b * b, 0);

                let slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX) || 0; // in units/second
                let intercept = (sumY - slope * sumX) / n;

                let rSquared = calculateRSquared(x, y, slope, intercept);
                localSlopes.push(slope);
                intercepts.push(intercept);
                rSquaredValues.push(rSquared);
            }

            // Find Vmax (maximum slope with R-squared >= 0.95)
            let Vmax = 0;
            let threshold = 0.2 // Vmax must be larger than threshold per hour
            let startVMax = -1;
            let endVMax = -1;
            let yVMaxstart = 0;
            let yVMaxend = 0;
            for (let i = 0; i < localSlopes.length; i++) {
                adjustedLocal = 3600*localSlopes[i];
                // console.log("local Slop is ", adjustedLocal);
                if (rSquaredValues[i] >= 0.95 && localSlopes[i] > Vmax && adjustedLocal > threshold) {
                    Vmax = localSlopes[i];
                    startVMax = Number(i);
                    endVMax = startVMax + Number(window_size) - 1;
                    yVMaxstart = Vmax*allTimestamps[startVMax] + intercepts[i];
                    yVMaxend = Vmax*allTimestamps[endVMax] + intercepts[i];
                }
            }
            
            
            // Determine linear period (slopes >= 0.8 * Vmax)
            let linearStartIdx = -1;
            let linearEndIdx = -1;
            if (Vmax !== 0) {
                for (let i = 0; i < localSlopes.length; i++) {
                    if (localSlopes[i] >= 0.7 * Vmax) {
                        if (linearStartIdx === -1) linearStartIdx = i;
                        linearEndIdx = i;
                    }
                }
            }
            

            // Calculate linear period parameters
            let linearSlope = null;
            let linearIntercept = 0;
            let linearXMin = 0;
            let linearXMax = 0;
            let linearYMin = 0;
            let linearYMax = 0;
            let saturationValue = "--";
            let timeToSaturation = "--";

            if (linearStartIdx !== -1 && linearEndIdx !== -1) {
                // Adjust indices to include full window at the end
                let start = linearStartIdx;
                let end = linearEndIdx + window_size;

                if (end > allTimestamps.length) {
                    end = allTimestamps.length;
                }

                let x = allTimestamps.slice(start, end);
                let y = allValues.slice(start, end);

                // Linear regression for the entire linear period
                let n = x.length;
                let sumX = x.reduce((a, b) => a + b, 0);
                let sumY = y.reduce((a, b) => a + b, 0);
                let sumXY = x.reduce((a, b, i) => a + b * y[i], 0);
                let sumXX = x.reduce((a, b) => a + b * b, 0);

                linearSlope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX) || 0; // In units/second
                linearIntercept = (sumY - linearSlope * sumX) / n;

                linearXMin = allTimestamps[start]; //in seconds
                linearXMax = allTimestamps[end - 1];
                linearYMin = linearSlope*linearXMin + linearIntercept; // in units (absorbance)
                linearYMax = linearSlope*linearXMax + linearIntercept;

                // Saturation point (end of linear period)
                // saturationValue = end < allValues.length ? linearYMax.toFixed(2) : "--";
                if (end >= allValues.length) {
                    saturationValue = "--";
                } else {
                    let theRest = allValues.slice(end, allValues.length);
                    sortedValuesForRest = [...theRest].sort((a, b) => a - b);
                    saturationValue = sortedValuesForRest[Math.floor(theRest.length/2)].toFixed(2);
                }
                timeToSaturation = end < allTimestamps.length ? (allTimestamps[end - 1] - allTimestamps[start]).toFixed(2) : null;
                timeStartSaturation = end < allTimestamps.length ? (allTimestamps[end - 1]).toFixed(2) : null;
            } else {
                sortedValues = [...allValues].sort((a, b) => a - b);
                saturationValue = sortedValues[allValues.length/2];
                timeToSaturation = allTimestamps[0];
                timeStartSaturation = allTimestamps[0];
            }
            return {
                slope: linearSlope, // Overall slope for compatibility
                intercept: linearIntercept.toFixed(2),
                saturationValue,
                timeToSaturation,
                Vmax: Vmax.toFixed(6),
                linearYMin: linearYMin.toFixed(2),
                linearYMax: linearYMax.toFixed(2),
                linearXMin: linearStartIdx !== -1 ? linearXMin.toFixed(2) : null,
                linearXMax: linearEndIdx !== -1 ? linearXMax.toFixed(2) : null,
                startVMax: startVMax !== -1 ? allTimestamps[startVMax].toFixed(2) : null,
                endVMax: endVMax !== -1 ? allTimestamps[endVMax].toFixed(2) : null,
                yVMaxstart: yVMaxstart,
                yVMaxend: yVMaxend,
                timeStartSaturation: timeStartSaturation,
            };
        }

        function averageDuplicates(xColumn, yColumn) {
            const dataMap = new Map();
            
            // Group YColumn values by XColumn values
            for (let i = 0; i < xColumn.length; i++) {
                if (!dataMap.has(xColumn[i])) {
                    dataMap.set(xColumn[i], []);
                }
                dataMap.get(xColumn[i]).push(yColumn[i]);
            }

            // Calculate average for each group
            const uniqueX = [];
            const averagedY = [];
            for (let [x, yValues] of dataMap) {
                uniqueX.push(x);
                const avg = yValues.reduce((sum, value) => sum + value, 0) / yValues.length;
                averagedY.push(avg);
            }

            return { XColumn: uniqueX, YColumn: averagedY };
        }

        function createChart(canvasId, allXColumn, allYColumn, label, unit, timeUnit, range, conversionFactor, analysis, isFullDisplay, refCalPoint=null, forThisBlankType=false) {
            const ctx = document.getElementById(canvasId).getContext('2d');
            if (!ctx || allXColumn.length === 0 || allYColumn.length === 0) {
                console.error("Invalid chart data or context:", { canvasId, allYColumn, allYColumn });
                return null;
            }
            // console.log(`With current mode is ${currentMeasurementMode}, analysis should be `, analysis);
            let chartScaleConstant = 60;
            let adjustedSlope = null;
            let adjustedLinearStart = null;
            let adjustedLinearEnd = null;
            let adjustedVmax = null;
            let adjustedVmaxStart = null;
            let adjustedVmaxEnd = null;
            let adjustedTimeToSaturationDisplay = null;
            let adjustedSaturationValue = null;

            if (analysis) {
                adjustedSlope = analysis.slope ? (parseFloat(analysis.slope)/conversionFactor).toFixed(4) : "--";
                adjustedLinearStart = analysis.linearXMin ? (parseFloat(analysis.linearXMin)*conversionFactor).toFixed(2) : "--";
                adjustedLinearEnd = analysis.linearXMax ? (parseFloat(analysis.linearXMax)*conversionFactor).toFixed(2) : "--";
                adjustedVmax = parseFloat(analysis.Vmax)/conversionFactor;
                adjustedVmaxStart = analysis.startVMax ? (parseFloat(analysis.startVMax)*conversionFactor).toFixed(2) : "--";
                adjustedVmaxEnd = analysis.endVMax ? (parseFloat(analysis.endVMax)*conversionFactor).toFixed(2) : "--";
                adjustedTimeToSaturationDisplay = (analysis.timeToSaturation !== null) ? (parseFloat(analysis.timeToSaturation) * conversionFactor).toFixed(2) : "--";

                adjustedSaturationValue = (analysis.timeToSaturation !== null) ? parseFloat(analysis.saturationValue).toFixed(3) : "--";
                adjustedVmax = (3600*adjustedVmax).toFixed(5) !== "0.00000" ? adjustedVmax.toFixed(5) : "--";
            }
            const { XColumn, YColumn } = averageDuplicates(allXColumn, allYColumn);
            let chart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: XColumn,
                    datasets: [{
                        label: label,
                        data: YColumn,
                        borderColor: canvasId === 'blanked-canvas' ? 'rgb(255, 99, 132)' : 'rgb(75, 192, 192)',
                        tension: 0.1,
                        fill: false
                    }]
                },
                options: {
                    animation: false,
                    scales: {
                        x: {
                            type: 'linear', // Ensure linear scale for numeric data
                            title: { display: true, text: timeUnit ? `Time (${timeUnit})` : 'Concentration (nM/l)' },
                            min: 0, // Set minimum value
                            max: Math.max(...XColumn), // Set max with a 10% buffer
                            ticks: {
                                stepSize: 25, // Set a uniform step size (adjust based on your data range)
                                callback: function(value) {
                                    return Number(value).toFixed(0); // Ensure integer ticks
                                }
                            }
                        },
                        y: {
                            type: 'linear',
                            title: { display: true, text: unit !== "NONE" ? unit : '' },
                            min: 0, // Start from 0
                            max: Math.max(...YColumn) * 1.1, // Set max with a 10% buffer
                            ticks: {
                                stepSize: 0.001, // Set a uniform step size (adjust based on your data range)
                                callback: function(value) {
                                    return Number(value).toFixed(3); // Format to 3 decimal places
                                }
                            }
                        }
                    },
                    plugins: {
                        annotation: {
                            annotations: {
                                ...(isFullDisplay && currentMeasurementMode === "point" && forThisBlankType && {refCalLine: {
                                      type: 'vertical',
                                      borderColor: 'rgba(255, 0, 0, 0.5)',
                                      borderWidth: 3,
                                      xMin: parseFloat(refCalPoint - XColumn[0]/conversionFactor)/chartScaleConstant,
                                      xMax: parseFloat(refCalPoint - XColumn[0]/conversionFactor)/chartScaleConstant,
                                      yMin: 0,
                                      yMax: Math.max(...YColumn),
                                      label: {
                                        display: true,
                                        content: 'RefCal',
                                        position: 'start'
                                      }
                                    }
                                }),
                                ...(isFullDisplay && currentMeasurementMode === "kinetics" && analysis.startVMax && {VMaxLine: {
                                      type: 'line',
                                      borderColor: 'rgba(255, 0, 0, 0.5)',
                                      borderWidth: 3,
                                      xMin: parseFloat((analysis.startVMax - XColumn[0]/conversionFactor)/chartScaleConstant),
                                      xMax: parseFloat((analysis.endVMax - XColumn[0]/conversionFactor)/chartScaleConstant),
                                      yMin: parseFloat(analysis.yVMaxstart),
                                      yMax: parseFloat(analysis.yVMaxend),
                                      label: {
                                        display: true,
                                        content: 'VMax',
                                        position: 'start'
                                      }
                                    }
                                }),
                                ...(isFullDisplay && currentMeasurementMode === "kinetics" && analysis.linearXMin && {regressionLine: {
                                      type: 'line',
                                      borderColor: 'rgba(0, 0, 255, 0.5)',
                                      borderWidth: 3,
                                      xMin: parseFloat((analysis.linearXMin - XColumn[0]/conversionFactor)/chartScaleConstant),
                                      xMax: parseFloat((analysis.linearXMax - XColumn[0]/conversionFactor)/chartScaleConstant),
                                      yMin: parseFloat(analysis.linearYMin),
                                      yMax: parseFloat(analysis.linearYMax),
                                      label: {
                                        display: true,
                                        content: 'Linear',
                                        position: 'middle'
                                      }
                                    }
                                }),
                                ...(isFullDisplay && currentMeasurementMode === "kinetics" && analysis.saturationValue !== "--" && {saturationLine: {
                                      type: 'line',
                                      borderColor: 'rgba(255, 0, 255, 0.5)',
                                      borderWidth: 3,
                                      xMin: parseFloat((analysis.timeStartSaturation - XColumn[0]/conversionFactor)/chartScaleConstant),
                                      xMax: Math.max(...XColumn)*100,
                                      yMin: parseFloat(analysis.saturationValue),
                                      yMax: parseFloat(analysis.saturationValue),
                                      label: {
                                        display: true,
                                        content: 'Sat',
                                        position: 'end'
                                      }
                                    }
                                })
                            }
                        }
                    }
                }
            });
            if (analysis) {
                chart.data.datasets[0].analysis = {
                    slope: adjustedSlope,
                    linearStart: adjustedLinearStart,
                    linearEnd: adjustedLinearEnd,
                    saturationValue: adjustedSaturationValue,
                    timeToSaturation: adjustedTimeToSaturationDisplay,
                    Vmax: adjustedVmax,
                    VmaxStart: adjustedVmaxStart,
                    VmaxEnd: adjustedVmaxEnd, 
                    MeasUnit: unit,
                    Meas: label
                }; // Store adjusted analysis for display
            }
            console.log("The chart is", chart);
            return chart;
        }

        function updatePlot(data, range, timeUnit, window_size, unit, isSplitMode, isFullDisplay=false, refCalPoint=null, forBlankType=null,
            XColumn = "Timestamp", YColumn = "Value") {
            destroyCharts();
            $("#plot-canvas, #blanked-canvas, #non-blanked-canvas").hide();
            $("#analysis-info").text("");

            data.sort((a, b) => a[XColumn] - b[XColumn]);
            data = data.filter(row => row[XColumn] !== "NONE" && row[YColumn] !== "NONE");

            const baseMultiplier = getTimeUnitMultiplier('seconds');
            const targetMultiplier = getTimeUnitMultiplier(timeUnit);
            const conversionFactor = baseMultiplier / targetMultiplier;

            // Determine if data has Blank or BlankType column
            const hasBlankType = data.some(row => 'BlankType' in row);
            const hasBlank = data.some(row => 'Blanked' in row);

            // Prepare data based on column type
            let allXColumn, allYColumn, allBlankedData, allNonBlankedData;
            
            if (hasBlankType) {
                allXColumn = data.filter(row => !forBlankType || row['BlankType'] === forBlankType || row['BlankType'] === "MIXED")
                                .map(row => row[XColumn]);
                allYColumn = data.filter(row => !forBlankType || row['BlankType'] === forBlankType || row['BlankType'] === "MIXED")
                                .map(row => row[YColumn]);
                allBlankedData = data.filter(row => row['BlankType'] === "BLANKED");
                allNonBlankedData = data.filter(row => row['BlankType'] === "NON-BLANKED");
            } else if (hasBlank) {
                allXColumn = data.map(row => row[XColumn]);
                allYColumn = data.map(row => row[YColumn]);
                allBlankedData = data.filter(row => row['Blanked'] === true || row['Blanked'] === 1);
                allNonBlankedData = data.filter(row => row['Blanked'] === false || row['Blanked'] === 0);
            } else {
                console.warn("No Blank or BlankType column found in data");
                return;
            }

            const allBlankedXColumn = allBlankedData.map(row => row[XColumn]);
            const allBlankedYColumn = allBlankedData.map(row => row[YColumn]);
            const allNonBlankedXColumn = allNonBlankedData.map(row => row[XColumn]);
            const allNonBlankedYColumn = allNonBlankedData.map(row => row[YColumn]);

            console.log("X Column is", XColumn);
            let filteredData = null;
            let XColumnVals = null;
            let YColumnVals = null;

            if (currentMeasurementMode !== "calibrate") {
                if (isFullDisplay === true) {
                    range = Number.MAX_VALUE;
                }
                const rangeInSeconds = range * getTimeUnitMultiplier(timeUnit);
                const mostRecentTime = Math.max(...allXColumn);
                const timeThreshold = mostRecentTime - rangeInSeconds;
                
                filteredData = hasBlankType 
                    ? data.filter(row => row[XColumn] >= timeThreshold && 
                                   (!forBlankType || row['BlankType'] === forBlankType || row['BlankType'] === "MIXED"))
                    : data.filter(row => row[XColumn] >= timeThreshold);
                    
                if (filteredData.length === 0) {
                    console.warn("No data after filtering with threshold:", timeThreshold);
                    return;
                }
                XColumnVals = filteredData.map(row => Number((row[XColumn] * conversionFactor).toFixed(2)));
                YColumnVals = filteredData.map(row => row[YColumn]);
            } else {
                filteredData = hasBlankType 
                    ? data.filter(row => !forBlankType || row['BlankType'] === forBlankType || row['BlankType'] === "MIXED")
                    : data;
                XColumnVals = allXColumn;
                YColumnVals = allYColumn;
            }

            let measurementLabel = null;
            if (currentMeasurementMode !== "calibrate") {
                measurementLabel = filteredData.length > 0 && 'Measurement' in filteredData[0] 
                    ? filteredData[0]['Measurement'] 
                    : 'Measurement';
            } else {
                measurementLabel = filteredData.length > 0 && 'Concentration' in filteredData[0]
                    ? `${YColumn} against ${XColumn}`
                    : 'Correlation';
            }

            if (isSplitMode) {
                const blankedData = hasBlankType 
                    ? filteredData.filter(row => row['BlankType'] === "BLANKED")
                    : filteredData.filter(row => row['Blanked'] === true || row['Blanked'] === 1);
                const nonBlankedData = hasBlankType 
                    ? filteredData.filter(row => row['BlankType'] === "NON-BLANKED")
                    : filteredData.filter(row => row['Blanked'] === false || row['Blanked'] === 0);

                const blankedXColumn = blankedData.map(row => Number((row[XColumn] * conversionFactor).toFixed(2)));
                const blankedYColumn = blankedData.map(row => row[YColumn]);
                const nonBlankedXColumn = nonBlankedData.map(row => Number((row[XColumn] * conversionFactor).toFixed(2)));
                const nonBlankedYColumn = nonBlankedData.map(row => row[YColumn]);

                let analysis_blanked = null;
                let analysis_nonblanked = null;
                if (currentMeasurementMode !== "calibrate") {
                    analysis_blanked = calculateSlopeAndSaturation(allBlankedXColumn, allBlankedYColumn, window_size);
                    analysis_nonblanked = calculateSlopeAndSaturation(allNonBlankedXColumn, allNonBlankedYColumn, window_size);
                }

                $("#blanked-canvas, #non-blanked-canvas").show();
                blankedChart = createChart(
                    'blanked-canvas',
                    blankedXColumn,
                    blankedYColumn,
                    `${measurementLabel} (Blanked) ${unit !== "NONE" ? `(${unit})` : ""}`,
                    unit,
                    timeUnit,
                    range,
                    conversionFactor,
                    analysis_blanked,
                    isFullDisplay,
                    refCalPoint,
                    (forBlankType === "BLANKED")
                );
                nonBlankedChart = createChart(
                    'non-blanked-canvas',
                    nonBlankedXColumn,
                    nonBlankedYColumn,
                    `${measurementLabel} (Non-Blanked) ${unit !== "NONE" ? `(${unit})` : ""}`,
                    unit,
                    timeUnit,
                    range,
                    conversionFactor,
                    analysis_nonblanked,
                    isFullDisplay,
                    refCalPoint,
                    (forBlankType === "NON-BLANKED")
                );

                if (currentMeasurementMode !== "calibrate") {
                    $("#analysis-info").html(
                        `<span style="color: rgb(255, 99, 132);">
                        Blanked: Slope = ${blankedChart?.data.datasets[0].analysis.slope} ${unit !== "NONE" ? unit : ''}/${timeUnit}, 
                        Linear start = ${blankedChart?.data.datasets[0].analysis.linearStart} ${timeUnit},
                        Linear end = ${blankedChart?.data.datasets[0].analysis.linearEnd} ${timeUnit}, <br/>
                        Vmax = ${blankedChart?.data.datasets[0].analysis.Vmax}${unit !== "NONE" ? unit : ''}/${timeUnit}, 
                        VmaxStart = ${blankedChart?.data.datasets[0].analysis.VmaxStart} ${timeUnit}, 
                        VmaxEnd = ${blankedChart?.data.datasets[0].analysis.VmaxEnd} ${timeUnit}, <br/>
                        Saturation = ${blankedChart?.data.datasets[0].analysis.saturationValue}, 
                        Time to Saturation = ${blankedChart?.data.datasets[0].analysis.timeToSaturation} ${timeUnit}<br> </span>` +
                        `<span style="color: rgb(75, 192, 192);">
                        Non-Blanked: Slope = ${nonBlankedChart?.data.datasets[0].analysis.slope} ${unit !== "NONE" ? unit : ''}/${timeUnit}, 
                        Linear start = ${nonBlankedChart?.data.datasets[0].analysis.linearStart} ${timeUnit},
                        Linear end = ${nonBlankedChart?.data.datasets[0].analysis.linearEnd} ${timeUnit}, <br/>
                        Vmax = ${nonBlankedChart?.data.datasets[0].analysis.Vmax}${unit !== "NONE" ? unit : ''}/${timeUnit}, 
                        VmaxStart = ${nonBlankedChart?.data.datasets[0].analysis.VmaxStart} ${timeUnit}, 
                        VmaxEnd = ${nonBlankedChart?.data.datasets[0].analysis.VmaxEnd} ${timeUnit}, <br/>
                        Saturation = ${nonBlankedChart?.data.datasets[0].analysis.saturationValue}, 
                        Time to Saturation = ${nonBlankedChart?.data.datasets[0].analysis.timeToSaturation} ${timeUnit} </span>`
                    );
                    return {
                        split: true,
                        vmax_blanked: analysis_blanked.Vmax,
                        slope_blanked: analysis_blanked.slope,
                        sat_blanked: analysis_blanked.saturationValue,
                        time_to_sat_blanked: analysis_blanked.timeToSaturation,
                        vmax_non_blanked: analysis_nonblanked.Vmax,
                        slope_non_blanked: analysis_nonblanked.slope,
                        sat_non_blanked: analysis_nonblanked.saturationValue,
                        time_to_sat_non_blanked: analysis_nonblanked.timeToSaturation,
                        meas: data[0]["Measurement"],
                        meas_unit: data[0]["Unit"]
                    }
                } else {
                    $("#analysis-info").addClass("hidden");
                    return null;
                }
            } else {
                let mixAnalysis = null;
                if (currentMeasurementMode !== "calibrate") {
                    mixAnalysis = calculateSlopeAndSaturation(allXColumn, allYColumn, window_size);
                }
                $("#plot-canvas").show();
                myChart = createChart(
                    'plot-canvas',
                    XColumnVals,
                    YColumnVals,
                    `${measurementLabel} ${unit !== "NONE" ? `(${unit})` : ""}`,
                    unit,
                    timeUnit,
                    range,
                    conversionFactor,
                    mixAnalysis,
                    isFullDisplay,
                    refCalPoint,
                    (forBlankType === "MIXED")
                );
                if (currentMeasurementMode !== "calibrate") {
                    const analysisDisplay = myChart?.data.datasets[0].analysis;
                    $("#analysis-info").html(
                        `Slope = ${analysisDisplay.slope} ${unit !== "NONE" ? unit : ''}/${timeUnit},  
                        Linear start = ${analysisDisplay.linearStart} ${timeUnit},
                        Linear end = ${analysisDisplay.linearEnd} ${timeUnit}, <br/>
                        Vmax = ${analysisDisplay.Vmax}${unit !== "NONE" ? unit : ''}/${timeUnit}, 
                        VmaxStart = ${analysisDisplay.VmaxStart} ${timeUnit}, 
                        VmaxEnd = ${analysisDisplay.VmaxEnd} ${timeUnit}, <br/>
                        Saturation = ${analysisDisplay.saturationValue}, 
                        Time to Saturation = ${analysisDisplay.timeToSaturation} ${timeUnit}`
                    );
                    return {
                        split: false,
                        vmax: mixAnalysis.Vmax,
                        slope: mixAnalysis.slope,
                        sat: mixAnalysis.saturationValue,
                        time_to_sat: mixAnalysis.timeToSaturation,
                        meas: data[0]["Measurement"],
                        meas_unit: data[0]["Unit"]
                    }
                } else {
                    $("#analysis-info").addClass("hidden");
                    return null;
                }
            }
        }

        function getTimeUnitMultiplier(unit) {
            const multipliers = {
                'seconds': 1,
                'minutes': 60,
                'hours': 3600
            };
            return multipliers[unit] || 1;
        }

        function exportData() {
            if ($("#time-unit").val() === "minutes") {
                const saveDir = $("#save-dir").val() || "";
                const saveFile = $("#save-file").val() || "results";
                const concentration = $("#con-value-read").val() || "NONE";
                const timeUnit = $("#time-unit").val();
                // const fullPath = saveDir + delimiter + saveFile;
                // const timePoint = $("#exp-json-time-value").val(); 
                let analysisData = null;
                let newFile = true;
                if (currentMeasurementMode === "kinetics") {
                    switch ($("#exp-json-blank-type").val()) {
                        case "MIXED":
                            if (!$("#split-mode").is(":checked")) {
                                analysisData = {
                                    Vmax: analysis.vmax * getTimeUnitMultiplier('minutes'),
                                    slope: analysis.slope * getTimeUnitMultiplier('minutes'),
                                    saturationValue: analysis.sat,
                                    timeToSaturation: analysis.time_to_sat / getTimeUnitMultiplier('minutes'),
                                    measurement: analysis.meas,
                                    measUnit: analysis.meas_unit
                                };
                            }
                            break;

                        case "BLANKED":
                            if ($("#split-mode").is(":checked")) {
                                analysisData = {
                                    Vmax: analysis.vmax_blanked * getTimeUnitMultiplier('minutes'),
                                    slope: analysis.slope_blanked * getTimeUnitMultiplier('minutes'),
                                    saturationValue: analysis.sat_blanked,
                                    timeToSaturation: analysis.time_to_sat_blanked / getTimeUnitMultiplier('minutes'),
                                    measurement: analysis.meas,
                                    measUnit: analysis.meas_unit
                                };
                            }
                            break;

                        case "NON-BLANKED": 
                            if ($("#split-mode").is(":checked")) {
                                analysisData = {
                                    Vmax: analysis.vmax_non_blanked * getTimeUnitMultiplier('minutes'),
                                    slope: analysis.slope_non_blanked * getTimeUnitMultiplier('minutes'),
                                    saturationValue: analysis.sat_non_blanked,
                                    timeToSaturation: analysis.time_to_sat_non_blanked / getTimeUnitMultiplier('minutes'),
                                    measurement: analysis.meas,
                                    measUnit: analysis.meas_unit
                                };
                            }
                            break;
                    }
                    sendExportData(saveDir, saveFile, analysisData, concentration, timeUnit, $("#exp-json-blank-type").val());

                } else if (currentMeasurementMode === "point") {
                    analysisData = {
                        estValue: globalEstimatedValue,
                        timePoint: currExpTimePoint,
                        measurement: analysis.meas,
                        measUnit: analysis.meas_unit
                    } 
                    sendExportData(saveDir, saveFile, analysisData, concentration, timeUnit, $("#exp-json-blank-type").val());
                }
            } else {
                alert(`Please change your units in Display Range section from ${$("#time-unit").val()} to minutes!`);
            }

        function sendExportData(saveDir, saveFile, analysisData, concentration, timeUnit, blankedType, newFile=true) {
                if (analysisData) {
                    const data = {
                        save_dir: saveDir,
                        save_file: saveFile,
                        vmax: analysisData.Vmax !== "--" ? analysisData.Vmax : "NONE",
                        slope: analysisData.slope !== "--" ? analysisData.slope : "NONE",
                        sat: analysisData.saturationValue !== "--" ? analysisData.saturationValue : "NONE",
                        timeSat : analysisData.timeToSaturation !== "--" ? analysisData.timeToSaturation : "NONE",
                        con: concentration,
                        measUnit: analysisData.measUnit, 
                        blanked: blankedType,
                        timeUnit: timeUnit,
                        newFile: newFile,
                        measMode: currentMeasurementMode,
                        meas: analysisData.measurement,
                        estValue: analysisData.estValue,
                        timePoint: analysisData.timePoint
                    };
                    $.ajax({
                        url: '/export_data',
                        type: 'POST',
                        contentType: 'application/json',
                        data: JSON.stringify(data),
                        success: function(response) {
                            console.log("Export response:", response);
                            if (response.status === 'success') {
                                alert(`Success: ${response.message}!`);
                            } else {
                                alert(`Error: ${response.message}`);
                            }
                        },
                        error: function(jqXHR, textStatus, errorThrown) {
                            console.log("AJAX error:", textStatus, errorThrown);
                            alert("Error exporting data");
                        }
                    });
                } else {
                    alert("No analysis data available to export. If you'd like to export Blank/NonBlank in kinetics mode, must enable Split mode, and vice versa!");
                }
            }
        }

        function runScript() {
            const baseDir = $("#base-dir").val() || "";
            const baseName = $("#base-name").val() || "";
            $("#base-dir").prop('disabled', true);
            $("#base-name").prop('disabled', true);
            $.ajax({
                url: '/run_script',
                type: 'POST',
                contentType: 'application/json',
                data: JSON.stringify({ base_dir: baseDir, base_name: baseName }),
                success: function(response) {
                    console.log("Run script response:", response);
                    if (response.status === 'success') {
                        scriptRunning = true;
                        $("#run-script-btn").prop('disabled', true);
                        $("#terminate-script-btn").prop('disabled', false);
                        $("#log-display").text("Script started...\n");
                    } else {
                        $("#log-display").text(`Error: ${response.message}\n`);
                        $("#base-dir").prop('disabled', false);
                        $("#base-name").prop('disabled', false);
                    }
                },
                error: function(jqXHR, textStatus, errorThrown) {
                    console.log("AJAX error:", textStatus, errorThrown);
                    $("#log-display").text(`Error: Failed to start script\n`);
                    $("#base-dir").prop('disabled', false);
                    $("#base-name").prop('disabled', false);
                }
            });
        }

        function terminateScript() {
            $.ajax({
                url: '/terminate_script',
                type: 'POST',
                contentType: 'application/json',
                success: function(response) {
                    console.log("Terminate script response:", response);
                    if (response.status === 'success') {
                        scriptRunning = false;
                        $("#run-script-btn").prop('disabled', false);
                        $("#terminate-script-btn").prop('disabled', true);
                        $("#base-dir").prop('disabled', false);
                        $("#base-name").prop('disabled', false);
                        $("#log-display").append("Script terminated.\n");
                    } else {
                        $("#log-display").append(`Error: ${response.message}\n`);
                        if (response.message.includes('No process running')) {
                            scriptRunning = false;
                            $("#run-script-btn").prop('disabled', false);
                            $("#terminate-script-btn").prop('disabled', true);
                            $("#base-dir").prop('disabled', false);
                            $("#base-name").prop('disabled', false);
                        }
                    }
                },
                error: function(jqXHR, textStatus, errorThrown) {
                    console.log("AJAX error:", textStatus, errorThrown);
                    $("#log-display").append(`Error: Failed to terminate script\n`);
                    scriptRunning = false;
                    $("#run-script-btn").prop('disabled', false);
                    $("#terminate-script-btn").prop('disabled', true);
                    $("#base-dir").prop('disabled', false);
                    $("#base-name").prop('disabled', false);
                }
            });
        }

        function fetchLogs() {
            $.get('/get_logs', function(response) {
                console.log("Logs response:", response);
                if (response.status === 'success') {
                    $("#log-display").text(response.logs);
                }
            }).fail(function(jqXHR, textStatus, errorThrown) {
                console.log("AJAX error:", textStatus, errorThrown);
                $("#log-display").append(`Error: Failed to fetch logs\n`);
            });
        }

        function clearLogs() {
            $.ajax({
                url: '/clear_logs',
                type: 'POST',
                contentType: 'application/json',
                success: function(response) {
                    console.log("Clear logs response:", response);
                    if (response.status === 'success') {
                        $("#log-display").text("");
                    } else {
                        $("#log-display").append(`Error: Failed to clear logs - ${response.message}\n`);
                    }
                },
                error: function(jqXHR, textStatus, errorThrown) {
                    console.log("AJAX error:", textStatus, errorThrown);
                    $("#log-display").append(`Error: Failed to clear logs - ${textStatus}\n`);
                }
            });
        }

        // Refresh data display according to range, unit, window size set
        setInterval(function() {
            if (currentFile) {
                if (currentMeasurementMode !== "calibrate") {
                    let range = $("#range-value").val();
                    let unit = $("#time-unit").val();
                    let window_size = $("#window-size").val();
                    fetchData(range, unit, window_size, currentFile, currentJSONcontent);
                    $("#data-display-section").removeClass("hidden");
                } else {
                    fetchData(null, null, null, currentFile, null);
                    $("#data-display-section").removeClass("hidden");
                }
            } else $("#data-display-section").addClass("hidden");
            if (!currentJSON) {
                $("#derived-concentration-section").addClass("hidden");
                $("#blank-derived-concentration-section").addClass("hidden");
                $("#non-blank-derived-concentration-section").addClass("hidden");
            }
        }, 2000);

    </script>
</body>
</html>